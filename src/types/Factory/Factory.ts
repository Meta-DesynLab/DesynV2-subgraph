// THIS IS AN AUTOGENERATED FILE. DO NOT EDIT THIS FILE DIRECTLY.

import {
  ethereum,
  JSONValue,
  TypedMap,
  Entity,
  Bytes,
  Address,
  BigInt
} from "@graphprotocol/graph-ts";

export class LOG_BLABS extends ethereum.Event {
  get params(): LOG_BLABS__Params {
    return new LOG_BLABS__Params(this);
  }
}

export class LOG_BLABS__Params {
  _event: LOG_BLABS;

  constructor(event: LOG_BLABS) {
    this._event = event;
  }

  get caller(): Address {
    return this._event.parameters[0].value.toAddress();
  }

  get blabs(): Address {
    return this._event.parameters[1].value.toAddress();
  }
}

export class LOG_DEL_WHITELIST extends ethereum.Event {
  get params(): LOG_DEL_WHITELIST__Params {
    return new LOG_DEL_WHITELIST__Params(this);
  }
}

export class LOG_DEL_WHITELIST__Params {
  _event: LOG_DEL_WHITELIST;

  constructor(event: LOG_DEL_WHITELIST) {
    this._event = event;
  }

  get spender(): Address {
    return this._event.parameters[0].value.toAddress();
  }

  get sort(): BigInt {
    return this._event.parameters[1].value.toBigInt();
  }

  get caller(): Address {
    return this._event.parameters[2].value.toAddress();
  }

  get token(): Address {
    return this._event.parameters[3].value.toAddress();
  }
}

export class LOG_MANAGER extends ethereum.Event {
  get params(): LOG_MANAGER__Params {
    return new LOG_MANAGER__Params(this);
  }
}

export class LOG_MANAGER__Params {
  _event: LOG_MANAGER;

  constructor(event: LOG_MANAGER) {
    this._event = event;
  }

  get manager(): Address {
    return this._event.parameters[0].value.toAddress();
  }

  get caller(): Address {
    return this._event.parameters[1].value.toAddress();
  }
}

export class LOG_NEW_POOL extends ethereum.Event {
  get params(): LOG_NEW_POOL__Params {
    return new LOG_NEW_POOL__Params(this);
  }
}

export class LOG_NEW_POOL__Params {
  _event: LOG_NEW_POOL;

  constructor(event: LOG_NEW_POOL) {
    this._event = event;
  }

  get caller(): Address {
    return this._event.parameters[0].value.toAddress();
  }

  get pool(): Address {
    return this._event.parameters[1].value.toAddress();
  }
}

export class LOG_ORACLE extends ethereum.Event {
  get params(): LOG_ORACLE__Params {
    return new LOG_ORACLE__Params(this);
  }
}

export class LOG_ORACLE__Params {
  _event: LOG_ORACLE;

  constructor(event: LOG_ORACLE) {
    this._event = event;
  }

  get caller(): Address {
    return this._event.parameters[0].value.toAddress();
  }

  get oracle(): Address {
    return this._event.parameters[1].value.toAddress();
  }
}

export class LOG_ROUTER extends ethereum.Event {
  get params(): LOG_ROUTER__Params {
    return new LOG_ROUTER__Params(this);
  }
}

export class LOG_ROUTER__Params {
  _event: LOG_ROUTER;

  constructor(event: LOG_ROUTER) {
    this._event = event;
  }

  get caller(): Address {
    return this._event.parameters[0].value.toAddress();
  }

  get router(): Address {
    return this._event.parameters[1].value.toAddress();
  }
}

export class LOG_USER_VAULT extends ethereum.Event {
  get params(): LOG_USER_VAULT__Params {
    return new LOG_USER_VAULT__Params(this);
  }
}

export class LOG_USER_VAULT__Params {
  _event: LOG_USER_VAULT;

  constructor(event: LOG_USER_VAULT) {
    this._event = event;
  }

  get vault(): Address {
    return this._event.parameters[0].value.toAddress();
  }

  get caller(): Address {
    return this._event.parameters[1].value.toAddress();
  }
}

export class LOG_VAULT extends ethereum.Event {
  get params(): LOG_VAULT__Params {
    return new LOG_VAULT__Params(this);
  }
}

export class LOG_VAULT__Params {
  _event: LOG_VAULT;

  constructor(event: LOG_VAULT) {
    this._event = event;
  }

  get vault(): Address {
    return this._event.parameters[0].value.toAddress();
  }

  get caller(): Address {
    return this._event.parameters[1].value.toAddress();
  }
}

export class LOG_WHITELIST extends ethereum.Event {
  get params(): LOG_WHITELIST__Params {
    return new LOG_WHITELIST__Params(this);
  }
}

export class LOG_WHITELIST__Params {
  _event: LOG_WHITELIST;

  constructor(event: LOG_WHITELIST) {
    this._event = event;
  }

  get spender(): Address {
    return this._event.parameters[0].value.toAddress();
  }

  get sort(): BigInt {
    return this._event.parameters[1].value.toBigInt();
  }

  get caller(): Address {
    return this._event.parameters[2].value.toAddress();
  }

  get token(): Address {
    return this._event.parameters[3].value.toAddress();
  }
}

export class MODULE_STATUS_CHANGE extends ethereum.Event {
  get params(): MODULE_STATUS_CHANGE__Params {
    return new MODULE_STATUS_CHANGE__Params(this);
  }
}

export class MODULE_STATUS_CHANGE__Params {
  _event: MODULE_STATUS_CHANGE;

  constructor(event: MODULE_STATUS_CHANGE) {
    this._event = event;
  }

  get etf(): Address {
    return this._event.parameters[0].value.toAddress();
  }

  get module(): Address {
    return this._event.parameters[1].value.toAddress();
  }

  get status(): boolean {
    return this._event.parameters[2].value.toBoolean();
  }
}

export class PAUSED_STATUS extends ethereum.Event {
  get params(): PAUSED_STATUS__Params {
    return new PAUSED_STATUS__Params(this);
  }
}

export class PAUSED_STATUS__Params {
  _event: PAUSED_STATUS;

  constructor(event: PAUSED_STATUS) {
    this._event = event;
  }

  get state(): boolean {
    return this._event.parameters[0].value.toBoolean();
  }
}

export class Factory extends ethereum.SmartContract {
  static bind(address: Address): Factory {
    return new Factory("Factory", address);
  }

  getBLabs(): Address {
    let result = super.call("getBLabs", "getBLabs():(address)", []);

    return result[0].toAddress();
  }

  try_getBLabs(): ethereum.CallResult<Address> {
    let result = super.tryCall("getBLabs", "getBLabs():(address)", []);
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toAddress());
  }

  getModuleStatus(etf: Address, module: Address): boolean {
    let result = super.call(
      "getModuleStatus",
      "getModuleStatus(address,address):(bool)",
      [ethereum.Value.fromAddress(etf), ethereum.Value.fromAddress(module)]
    );

    return result[0].toBoolean();
  }

  try_getModuleStatus(
    etf: Address,
    module: Address
  ): ethereum.CallResult<boolean> {
    let result = super.tryCall(
      "getModuleStatus",
      "getModuleStatus(address,address):(bool)",
      [ethereum.Value.fromAddress(etf), ethereum.Value.fromAddress(module)]
    );
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toBoolean());
  }

  getOracleAddress(): Address {
    let result = super.call(
      "getOracleAddress",
      "getOracleAddress():(address)",
      []
    );

    return result[0].toAddress();
  }

  try_getOracleAddress(): ethereum.CallResult<Address> {
    let result = super.tryCall(
      "getOracleAddress",
      "getOracleAddress():(address)",
      []
    );
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toAddress());
  }

  getUserVault(): Address {
    let result = super.call("getUserVault", "getUserVault():(address)", []);

    return result[0].toAddress();
  }

  try_getUserVault(): ethereum.CallResult<Address> {
    let result = super.tryCall("getUserVault", "getUserVault():(address)", []);
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toAddress());
  }

  getVault(): Address {
    let result = super.call("getVault", "getVault():(address)", []);

    return result[0].toAddress();
  }

  try_getVault(): ethereum.CallResult<Address> {
    let result = super.tryCall("getVault", "getVault():(address)", []);
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toAddress());
  }

  isLiquidityPool(b: Address): boolean {
    let result = super.call(
      "isLiquidityPool",
      "isLiquidityPool(address):(bool)",
      [ethereum.Value.fromAddress(b)]
    );

    return result[0].toBoolean();
  }

  try_isLiquidityPool(b: Address): ethereum.CallResult<boolean> {
    let result = super.tryCall(
      "isLiquidityPool",
      "isLiquidityPool(address):(bool)",
      [ethereum.Value.fromAddress(b)]
    );
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toBoolean());
  }

  isPaused(): boolean {
    let result = super.call("isPaused", "isPaused():(bool)", []);

    return result[0].toBoolean();
  }

  try_isPaused(): ethereum.CallResult<boolean> {
    let result = super.tryCall("isPaused", "isPaused():(bool)", []);
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toBoolean());
  }

  isTokenWhitelistedForVerify(sort: BigInt, token: Address): boolean {
    let result = super.call(
      "isTokenWhitelistedForVerify",
      "isTokenWhitelistedForVerify(uint256,address):(bool)",
      [
        ethereum.Value.fromUnsignedBigInt(sort),
        ethereum.Value.fromAddress(token)
      ]
    );

    return result[0].toBoolean();
  }

  try_isTokenWhitelistedForVerify(
    sort: BigInt,
    token: Address
  ): ethereum.CallResult<boolean> {
    let result = super.tryCall(
      "isTokenWhitelistedForVerify",
      "isTokenWhitelistedForVerify(uint256,address):(bool)",
      [
        ethereum.Value.fromUnsignedBigInt(sort),
        ethereum.Value.fromAddress(token)
      ]
    );
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toBoolean());
  }

  isTokenWhitelistedForVerify1(token: Address): boolean {
    let result = super.call(
      "isTokenWhitelistedForVerify",
      "isTokenWhitelistedForVerify(address):(bool)",
      [ethereum.Value.fromAddress(token)]
    );

    return result[0].toBoolean();
  }

  try_isTokenWhitelistedForVerify1(
    token: Address
  ): ethereum.CallResult<boolean> {
    let result = super.tryCall(
      "isTokenWhitelistedForVerify",
      "isTokenWhitelistedForVerify(address):(bool)",
      [ethereum.Value.fromAddress(token)]
    );
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toBoolean());
  }

  newLiquidityPool(): Address {
    let result = super.call(
      "newLiquidityPool",
      "newLiquidityPool():(address)",
      []
    );

    return result[0].toAddress();
  }

  try_newLiquidityPool(): ethereum.CallResult<Address> {
    let result = super.tryCall(
      "newLiquidityPool",
      "newLiquidityPool():(address)",
      []
    );
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toAddress());
  }
}

export class ConstructorCall extends ethereum.Call {
  get inputs(): ConstructorCall__Inputs {
    return new ConstructorCall__Inputs(this);
  }

  get outputs(): ConstructorCall__Outputs {
    return new ConstructorCall__Outputs(this);
  }
}

export class ConstructorCall__Inputs {
  _call: ConstructorCall;

  constructor(call: ConstructorCall) {
    this._call = call;
  }

  get oracle(): Address {
    return this._call.inputValues[0].value.toAddress();
  }

  get vault(): Address {
    return this._call.inputValues[1].value.toAddress();
  }

  get userVault(): Address {
    return this._call.inputValues[2].value.toAddress();
  }
}

export class ConstructorCall__Outputs {
  _call: ConstructorCall;

  constructor(call: ConstructorCall) {
    this._call = call;
  }
}

export class AddTokenToWhitelistCall extends ethereum.Call {
  get inputs(): AddTokenToWhitelistCall__Inputs {
    return new AddTokenToWhitelistCall__Inputs(this);
  }

  get outputs(): AddTokenToWhitelistCall__Outputs {
    return new AddTokenToWhitelistCall__Outputs(this);
  }
}

export class AddTokenToWhitelistCall__Inputs {
  _call: AddTokenToWhitelistCall;

  constructor(call: AddTokenToWhitelistCall) {
    this._call = call;
  }

  get sort(): Array<BigInt> {
    return this._call.inputValues[0].value.toBigIntArray();
  }

  get token(): Array<Address> {
    return this._call.inputValues[1].value.toAddressArray();
  }
}

export class AddTokenToWhitelistCall__Outputs {
  _call: AddTokenToWhitelistCall;

  constructor(call: AddTokenToWhitelistCall) {
    this._call = call;
  }
}

export class CollectCall extends ethereum.Call {
  get inputs(): CollectCall__Inputs {
    return new CollectCall__Inputs(this);
  }

  get outputs(): CollectCall__Outputs {
    return new CollectCall__Outputs(this);
  }
}

export class CollectCall__Inputs {
  _call: CollectCall;

  constructor(call: CollectCall) {
    this._call = call;
  }

  get token(): Address {
    return this._call.inputValues[0].value.toAddress();
  }
}

export class CollectCall__Outputs {
  _call: CollectCall;

  constructor(call: CollectCall) {
    this._call = call;
  }
}

export class NewLiquidityPoolCall extends ethereum.Call {
  get inputs(): NewLiquidityPoolCall__Inputs {
    return new NewLiquidityPoolCall__Inputs(this);
  }

  get outputs(): NewLiquidityPoolCall__Outputs {
    return new NewLiquidityPoolCall__Outputs(this);
  }
}

export class NewLiquidityPoolCall__Inputs {
  _call: NewLiquidityPoolCall;

  constructor(call: NewLiquidityPoolCall) {
    this._call = call;
  }
}

export class NewLiquidityPoolCall__Outputs {
  _call: NewLiquidityPoolCall;

  constructor(call: NewLiquidityPoolCall) {
    this._call = call;
  }

  get value0(): Address {
    return this._call.outputValues[0].value.toAddress();
  }
}

export class RegisterModuleCall extends ethereum.Call {
  get inputs(): RegisterModuleCall__Inputs {
    return new RegisterModuleCall__Inputs(this);
  }

  get outputs(): RegisterModuleCall__Outputs {
    return new RegisterModuleCall__Outputs(this);
  }
}

export class RegisterModuleCall__Inputs {
  _call: RegisterModuleCall;

  constructor(call: RegisterModuleCall) {
    this._call = call;
  }

  get etf(): Address {
    return this._call.inputValues[0].value.toAddress();
  }

  get module(): Address {
    return this._call.inputValues[1].value.toAddress();
  }
}

export class RegisterModuleCall__Outputs {
  _call: RegisterModuleCall;

  constructor(call: RegisterModuleCall) {
    this._call = call;
  }
}

export class RemoveModuleCall extends ethereum.Call {
  get inputs(): RemoveModuleCall__Inputs {
    return new RemoveModuleCall__Inputs(this);
  }

  get outputs(): RemoveModuleCall__Outputs {
    return new RemoveModuleCall__Outputs(this);
  }
}

export class RemoveModuleCall__Inputs {
  _call: RemoveModuleCall;

  constructor(call: RemoveModuleCall) {
    this._call = call;
  }

  get etf(): Address {
    return this._call.inputValues[0].value.toAddress();
  }

  get module(): Address {
    return this._call.inputValues[1].value.toAddress();
  }
}

export class RemoveModuleCall__Outputs {
  _call: RemoveModuleCall;

  constructor(call: RemoveModuleCall) {
    this._call = call;
  }
}

export class RemoveTokenFromWhitelistCall extends ethereum.Call {
  get inputs(): RemoveTokenFromWhitelistCall__Inputs {
    return new RemoveTokenFromWhitelistCall__Inputs(this);
  }

  get outputs(): RemoveTokenFromWhitelistCall__Outputs {
    return new RemoveTokenFromWhitelistCall__Outputs(this);
  }
}

export class RemoveTokenFromWhitelistCall__Inputs {
  _call: RemoveTokenFromWhitelistCall;

  constructor(call: RemoveTokenFromWhitelistCall) {
    this._call = call;
  }

  get sort(): Array<BigInt> {
    return this._call.inputValues[0].value.toBigIntArray();
  }

  get token(): Array<Address> {
    return this._call.inputValues[1].value.toAddressArray();
  }
}

export class RemoveTokenFromWhitelistCall__Outputs {
  _call: RemoveTokenFromWhitelistCall;

  constructor(call: RemoveTokenFromWhitelistCall) {
    this._call = call;
  }
}

export class SetBLabsCall extends ethereum.Call {
  get inputs(): SetBLabsCall__Inputs {
    return new SetBLabsCall__Inputs(this);
  }

  get outputs(): SetBLabsCall__Outputs {
    return new SetBLabsCall__Outputs(this);
  }
}

export class SetBLabsCall__Inputs {
  _call: SetBLabsCall;

  constructor(call: SetBLabsCall) {
    this._call = call;
  }

  get b(): Address {
    return this._call.inputValues[0].value.toAddress();
  }
}

export class SetBLabsCall__Outputs {
  _call: SetBLabsCall;

  constructor(call: SetBLabsCall) {
    this._call = call;
  }
}

export class SetByteCodesCall extends ethereum.Call {
  get inputs(): SetByteCodesCall__Inputs {
    return new SetByteCodesCall__Inputs(this);
  }

  get outputs(): SetByteCodesCall__Outputs {
    return new SetByteCodesCall__Outputs(this);
  }
}

export class SetByteCodesCall__Inputs {
  _call: SetByteCodesCall;

  constructor(call: SetByteCodesCall) {
    this._call = call;
  }

  get _bytecode(): Bytes {
    return this._call.inputValues[0].value.toBytes();
  }
}

export class SetByteCodesCall__Outputs {
  _call: SetByteCodesCall;

  constructor(call: SetByteCodesCall) {
    this._call = call;
  }
}

export class SetOracleCall extends ethereum.Call {
  get inputs(): SetOracleCall__Inputs {
    return new SetOracleCall__Inputs(this);
  }

  get outputs(): SetOracleCall__Outputs {
    return new SetOracleCall__Outputs(this);
  }
}

export class SetOracleCall__Inputs {
  _call: SetOracleCall;

  constructor(call: SetOracleCall) {
    this._call = call;
  }

  get oracle(): Address {
    return this._call.inputValues[0].value.toAddress();
  }
}

export class SetOracleCall__Outputs {
  _call: SetOracleCall;

  constructor(call: SetOracleCall) {
    this._call = call;
  }
}

export class SetProtocolPausedCall extends ethereum.Call {
  get inputs(): SetProtocolPausedCall__Inputs {
    return new SetProtocolPausedCall__Inputs(this);
  }

  get outputs(): SetProtocolPausedCall__Outputs {
    return new SetProtocolPausedCall__Outputs(this);
  }
}

export class SetProtocolPausedCall__Inputs {
  _call: SetProtocolPausedCall;

  constructor(call: SetProtocolPausedCall) {
    this._call = call;
  }

  get state(): boolean {
    return this._call.inputValues[0].value.toBoolean();
  }
}

export class SetProtocolPausedCall__Outputs {
  _call: SetProtocolPausedCall;

  constructor(call: SetProtocolPausedCall) {
    this._call = call;
  }
}

export class SetUserVaultCall extends ethereum.Call {
  get inputs(): SetUserVaultCall__Inputs {
    return new SetUserVaultCall__Inputs(this);
  }

  get outputs(): SetUserVaultCall__Outputs {
    return new SetUserVaultCall__Outputs(this);
  }
}

export class SetUserVaultCall__Inputs {
  _call: SetUserVaultCall;

  constructor(call: SetUserVaultCall) {
    this._call = call;
  }

  get newVault(): Address {
    return this._call.inputValues[0].value.toAddress();
  }
}

export class SetUserVaultCall__Outputs {
  _call: SetUserVaultCall;

  constructor(call: SetUserVaultCall) {
    this._call = call;
  }
}

export class SetVaultCall extends ethereum.Call {
  get inputs(): SetVaultCall__Inputs {
    return new SetVaultCall__Inputs(this);
  }

  get outputs(): SetVaultCall__Outputs {
    return new SetVaultCall__Outputs(this);
  }
}

export class SetVaultCall__Inputs {
  _call: SetVaultCall;

  constructor(call: SetVaultCall) {
    this._call = call;
  }

  get newVault(): Address {
    return this._call.inputValues[0].value.toAddress();
  }
}

export class SetVaultCall__Outputs {
  _call: SetVaultCall;

  constructor(call: SetVaultCall) {
    this._call = call;
  }
}
